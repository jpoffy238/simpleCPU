                        ; Demonstrate that the V flag works as described
                        ;
                        ; Returns with ERROR = 0 if the test passes, ERROR = 1 if the test fails
                        ;
                        ; Five (additional) memory locations are used: ERROR, S1, S2, U1, and U2
                        ; which can be located anywhere convenient in RAM
                        ;
0000                    PROCESSOR .6502
0000                    ORG



0000                    START:

0000  D8                TEST CLD       ; Clear decimal mode (just in case) for test
0001  A9 01                  LDA #1
0003  8D 7004                STA ERROR ; Store 1 in ERROR until test passes
0006  A9 80                  LDA #$80
0008  8D 7204                STA S1    ; Initalize S1 and S2 to -128 ($80)
000B  8D 7404                STA S2
000E  A9 00                  LDA #0
0010  8D 7604                STA U1    ; Initialize U1 and U2 to 0
0013  8D 7804                STA U2
0016  A0 01                  LDY #1    ; Initialize Y (used to set and clear the carry flag) to 1
0018  20 3F00           LOOP JSR ADD   ; Test ADC
001B  E0 01                  CPX #1
001D  F0 1F                  BEQ DONE  ; End if V and unsigned result do not agree (X = 1)
001F  20 5E00                JSR SUB   ; Test SBC
0022  E0 01                  CPX #1
0024  F0 18                  BEQ DONE  ; End if V and unsigned result do not agree (X = 1)
0026  EE 7204                INC S1
0029  EE 7604                INC U1
002C  D0 EA                  BNE LOOP  ; Loop until all 256 possibilities of S1 and U1 are tested
002E  EE 7404                INC S2
0031  EE 7804                INC U2
0034  D0 E2                  BNE LOOP  ; Loop until all 256 possibilities of S2 and U2 are tested
0036  88                     DEY
0037  10 DF                  BPL LOOP  ; Loop until both possiblities of the carry flag are tested
0039  A9 00                  LDA #0
003B  8D 7004                STA ERROR ; All tests pass, so store 0 in ERROR
003E  60                DONE RTS
                        ;
                        ; Test ADC
                        ;
                        ; X is initialized to 0
                        ; X is incremented when V = 1
                        ; X is incremented when the unsigned result predicts an overflow
                        ; Therefore, if the V flag and the unsigned result agree, X will be
                        ; incremented zero or two times (returning X = 0 or X = 2), and if they do
                        ; not agree X will be incremented once (returning X = 1)
                        ;
003F  C0 01             ADD  CPY #1   ; Set carry when Y = 1, clear carry when Y = 0
0041  AD 7204                LDA S1   ; Test twos complement addition
0044  6D 7404                ADC S2
0047  A2 00                  LDX #0   ; Initialize X to 0
0049  50 01                  BVC ADD1
004B  E8                     INX      ; Increment X if V = 1
004C  C0 01             ADD1 CPY #1   ; Set carry when Y = 1, clear carry when Y = 0
004E  AD 7604                LDA U1   ; Test unsigned addition
0051  6D 7804                ADC U2
0054  B0 04                  BCS ADD3 ; Carry is set if U1 + U2 >= 256
0056  30 01                  BMI ADD2 ; U1 + U2 < 256, A >= 128 if U1 + U2 >= 128
0058  E8                     INX      ; Increment X if U1 + U2 < 128
0059  60                ADD2 RTS
005A  10 01             ADD3 BPL ADD4 ; U1 + U2 >= 256, A <= 127 if U1 + U2 <= 383 ($17F)
005C  E8                     INX      ; Increment X if U1 + U2 > 383
005D  60                ADD4 RTS

                        ;
                        ; Test SBC
                        ;
                        ; X is initialized to 0
                        ; X is incremented when V = 1
                        ; X is incremented when the unsigned result predicts an overflow
                        ; Therefore, if the V flag and the unsigned result agree, X will be
                        ; incremented zero or two times (returning X = 0 or X = 2), and if they do
                        ; not agree X will be incremented once (returning X = 1)
                        ;
005E  C0 01             SUB  CPY #1   ; Set carry when Y = 1, clear carry when Y = 0
0060  AD 7204                LDA S1   ; Test twos complement subtraction
0063  ED 7404                SBC S2
0066  A2 00                  LDX #0   ; Initialize X to 0
0068  50 01                  BVC SUB1
006A  E8                     INX      ; Increment X if V = 1
006B  C0 01             SUB1 CPY #1   ; Set carry when Y = 1, clear carry when Y = 0
006D  AD 7604                LDA U1   ; Test unsigned subtraction
0070  ED 7804                SBC U2
0073  48                     PHA      ; Save the low byte of result on the stack
0074  A9 FF                  LDA #$FF
0076  E9 00                  SBC #$00 ; result = (65280 + U1) - U2, 65280 = $FF00
0078  C9 FE                  CMP #$FE
007A  D0 05                  BNE SUB4 ; Branch if result >= 65280 ($FF00) or result < 65024 ($FE00)
007C  68                     PLA      ; Get the low byte of result
007D  30 01                  BMI SUB3 ; result < 65280 ($FF00), A >= 128 if result >= 65152 ($FE80)
007F  E8                SUB2 INX      ; Increment X if result < 65152 ($FE80)
0080  60                SUB3 RTS
0081  68                SUB4 PLA      ; Get the low byte of result (does not affect the carry flag)
0082  90 FB                  BCC SUB2 ; The carry flag is clear if result < 65024 ($FE00)
0084  10 01                  BPL SUB5 ; result >= 65280 ($FF00), A <= 127 if result <= 65407 ($FF7F)
0086  E8                     INX      ; Increment X if result > 65407 ($FF7F)
0087  60                SUB5 RTS

0088   (03E8)           .DS 1000
0470  0000              ERROR: DW  0
0472  0000              S1: DW  0
0474  0000              S2: DW  0
0476  0000              U1: DW  0
0478  0000              U2: DW  0


00000 Total Error(s)

.                  0088    ADD                003F    ADD1               004C
ADD2               0059    ADD3               005A    ADD4               005D
DONE               003E    ERROR              0470    LOOP               0018
ORG                0000    PROCESSOR          0000    S1                 0472
S2                 0474    START              0000    SUB                005E
SUB1               006B    SUB2               007F    SUB3               0080
SUB4               0081    SUB5               0087    TEST               0000
U1                 0476    U2                 0478
